{
"version":3,
"file":"module$node_modules$golden_layout$dist$cjs$ts$items$row_or_column.js",
"lineCount":31,
"mappings":"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",
"sources":["node_modules/golden-layout/dist/cjs/ts/items/row-or-column.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$golden_layout$dist$cjs$ts$items$row_or_column\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RowOrColumn = void 0;\nconst config_1 = require(\"../config/config\");\nconst splitter_1 = require(\"../controls/splitter\");\nconst internal_error_1 = require(\"../errors/internal-error\");\nconst types_1 = require(\"../utils/types\");\nconst utils_1 = require(\"../utils/utils\");\nconst content_item_1 = require(\"./content-item\");\nconst stack_1 = require(\"./stack\");\n/** @public */\nclass RowOrColumn extends content_item_1.ContentItem {\n    /** @internal */\n    constructor(isColumn, layoutManager, config, \n    /** @internal */\n    _rowOrColumnParent) {\n        super(layoutManager, config, _rowOrColumnParent, RowOrColumn.createElement(document, isColumn));\n        this._rowOrColumnParent = _rowOrColumnParent;\n        /** @internal */\n        this._splitter = [];\n        this.isRow = !isColumn;\n        this.isColumn = isColumn;\n        this._childElementContainer = this.element;\n        this._splitterSize = layoutManager.layoutConfig.dimensions.borderWidth;\n        this._splitterGrabSize = layoutManager.layoutConfig.dimensions.borderGrabWidth;\n        this._isColumn = isColumn;\n        this._dimension = isColumn ? 'height' : 'width';\n        this._splitterPosition = null;\n        this._splitterMinPosition = null;\n        this._splitterMaxPosition = null;\n        switch (config.type) {\n            case types_1.ItemType.row:\n            case types_1.ItemType.column:\n                this._configType = config.type;\n                break;\n            default:\n                throw new internal_error_1.AssertError('ROCCCT00925');\n        }\n    }\n    newComponent(componentType, componentState, title, index) {\n        const itemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.newItem(itemConfig, index);\n    }\n    addComponent(componentType, componentState, title, index) {\n        const itemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.addItem(itemConfig, index);\n    }\n    newItem(itemConfig, index) {\n        index = this.addItem(itemConfig, index);\n        const createdItem = this.contentItems[index];\n        if (content_item_1.ContentItem.isStack(createdItem) && (config_1.ItemConfig.isComponent(itemConfig))) {\n            // createdItem is a Stack which was created to hold wanted component.  Return component\n            return createdItem.contentItems[0];\n        }\n        else {\n            return createdItem;\n        }\n    }\n    addItem(itemConfig, index) {\n        this.layoutManager.checkMinimiseMaximisedStack();\n        const resolvedItemConfig = config_1.ItemConfig.resolve(itemConfig);\n        const contentItem = this.layoutManager.createAndInitContentItem(resolvedItemConfig, this);\n        return this.addChild(contentItem, index, false);\n    }\n    /**\n     * Add a new contentItem to the Row or Column\n     *\n     * @param contentItem -\n     * @param index - The position of the new item within the Row or Column.\n     *                If no index is provided the item will be added to the end\n     * @param suspendResize - If true the items won't be resized. This will leave the item in\n     *                        an inconsistent state and is only intended to be used if multiple\n     *                        children need to be added in one go and resize is called afterwards\n     *\n     * @returns\n     */\n    addChild(contentItem, index, suspendResize) {\n        // contentItem = this.layoutManager._$normalizeContentItem(contentItem, this);\n        if (index === undefined) {\n            index = this.contentItems.length;\n        }\n        if (this.contentItems.length > 0) {\n            const splitterElement = this.createSplitter(Math.max(0, index - 1)).element;\n            if (index > 0) {\n                this.contentItems[index - 1].element.insertAdjacentElement('afterend', splitterElement);\n                splitterElement.insertAdjacentElement('afterend', contentItem.element);\n                if (this.isDocked(index - 1)) {\n                    utils_1.setElementDisplayVisibility(this._splitter[index - 1].element, false);\n                    utils_1.setElementDisplayVisibility(this._splitter[index].element, true);\n                }\n            }\n            else {\n                this.contentItems[0].element.insertAdjacentElement('beforebegin', splitterElement);\n                splitterElement.insertAdjacentElement('beforebegin', contentItem.element);\n            }\n        }\n        else {\n            this._childElementContainer.appendChild(contentItem.element);\n        }\n        super.addChild(contentItem, index);\n        const newItemSize = (1 / this.contentItems.length) * 100;\n        if (suspendResize === true) {\n            this.emitBaseBubblingEvent('stateChanged');\n            return index;\n        }\n        for (let i = 0; i < this.contentItems.length; i++) {\n            if (this.contentItems[i] === contentItem) {\n                contentItem[this._dimension] = newItemSize;\n            }\n            else {\n                const itemSize = this.contentItems[i][this._dimension] *= (100 - newItemSize) / 100;\n                this.contentItems[i][this._dimension] = itemSize;\n            }\n        }\n        this.updateSize();\n        this.emitBaseBubblingEvent('stateChanged');\n        this.validateDocking();\n        return index;\n    }\n    /**\n     * Removes a child of this element\n     *\n     * @param contentItem -\n     * @param keepChild - If true the child will be removed, but not destroyed\n     *\n     */\n    removeChild(contentItem, keepChild) {\n        const removedItemSize = contentItem[this._dimension];\n        const index = this.contentItems.indexOf(contentItem);\n        const splitterIndex = Math.max(index - 1, 0);\n        if (index === -1) {\n            throw new Error('Can\\'t remove child. ContentItem is not child of this Row or Column');\n        }\n        /**\n         * Remove the splitter before the item or after if the item happens\n         * to be the first in the row/column\n         */\n        if (this._splitter[splitterIndex]) {\n            this._splitter[splitterIndex].destroy();\n            this._splitter.splice(splitterIndex, 1);\n        }\n        if (splitterIndex < this._splitter.length) {\n            if (this.isDocked(splitterIndex))\n                utils_1.setElementDisplayVisibility(this._splitter[splitterIndex].element, false);\n        }\n        /**\n         * Allocate the space that the removed item occupied to the remaining items\n         */\n        const dockedCount = this.calculateDockedCount();\n        for (let i = 0; i < this.contentItems.length; i++) {\n            if (this.contentItems[i] !== contentItem) {\n                if (!this.isDocked(i))\n                    this.contentItems[i][this._dimension] += removedItemSize / (this.contentItems.length - 1 - dockedCount);\n            }\n        }\n        super.removeChild(contentItem, keepChild);\n        if (this.contentItems.length === 1 && this.isClosable === true) {\n            const childItem = this.contentItems[0];\n            this.contentItems.length = 0;\n            this._rowOrColumnParent.replaceChild(this, childItem, true);\n            if (this._rowOrColumnParent instanceof RowOrColumn) { // this check not included originally.\n                // If Ground, then validateDocking not require\n                this._rowOrColumnParent.validateDocking();\n            }\n        }\n        else {\n            this.updateSize();\n            this.emitBaseBubblingEvent('stateChanged');\n            this.validateDocking();\n        }\n    }\n    /**\n     * Replaces a child of this Row or Column with another contentItem\n     */\n    replaceChild(oldChild, newChild) {\n        const size = oldChild[this._dimension];\n        super.replaceChild(oldChild, newChild);\n        newChild[this._dimension] = size;\n        this.updateSize();\n        this.emitBaseBubblingEvent('stateChanged');\n    }\n    /**\n     * Called whenever the dimensions of this item or one of its parents change\n     */\n    updateSize() {\n        this.updateNodeSize();\n        this.updateContentItemsSize();\n    }\n    /**\n     * Dock or undock a child if it posiible\n     *\n     * @param contentItem -\n     * @param mode - Toggle if undefined\n     * @param collapsed - After docking\n     */\n    dock(contentItem, mode, collapsed) {\n        if (this.contentItems.length === 1)\n            throw new Error('Can\\'t dock child when it single');\n        const removedItemSize = contentItem[this._dimension];\n        // this is wrong - does not reflect the stack and component settings for header.show\n        const headerSize = this.layoutManager.layoutConfig.header.show === false ? 0 : this.layoutManager.layoutConfig.dimensions.headerHeight;\n        const index = this.contentItems.indexOf(contentItem);\n        const splitterIndex = Math.max(index - 1, 0);\n        if (index === -1) {\n            throw new Error('Can\\'t dock child. ContentItem is not child of this Row or Column');\n        }\n        const isDocked = contentItem.docker.docked;\n        if (mode !== undefined && mode === isDocked)\n            return;\n        if (isDocked) { // undock it\n            this._splitter[splitterIndex].element.style.display = '';\n            for (let i = 0; i < this.contentItems.length; i++) {\n                const newItemSize = contentItem.docker.size;\n                if (this.contentItems[i] === contentItem) {\n                    contentItem[this._dimension] = newItemSize;\n                }\n                else {\n                    const itemSize = this.contentItems[i][this._dimension] *= (100 - newItemSize) / 100;\n                    this.contentItems[i][this._dimension] = itemSize;\n                }\n            }\n            contentItem.setUndocked();\n        }\n        else { // dock\n            if (this.contentItems.length - this.calculateDockedCount() < 2)\n                throw new internal_error_1.AssertError('Can\\'t dock child when it is last in ' + this.type);\n            const autoside = {\n                column: {\n                    first: types_1.Side.top,\n                    last: types_1.Side.bottom,\n                },\n                row: {\n                    first: types_1.Side.left,\n                    last: types_1.Side.right,\n                }\n            };\n            const required = autoside[this._configType][index ? 'last' : 'first'];\n            if (contentItem.headerSide !== required)\n                contentItem.positionHeader(required);\n            if (this._splitter[splitterIndex]) {\n                utils_1.setElementDisplayVisibility(this._splitter[splitterIndex].element, false);\n            }\n            const dockedCount = this.calculateDockedCount();\n            for (let i = 0; i < this.contentItems.length; i++) {\n                if (this.contentItems[i] !== contentItem) {\n                    if (!this.isDocked(i))\n                        this.contentItems[i][this._dimension] += removedItemSize / (this.contentItems.length - 1 - dockedCount);\n                }\n                else\n                    this.contentItems[i][this._dimension] = 0;\n            }\n            contentItem.setDocked({\n                docked: true,\n                dimension: this._dimension,\n                size: removedItemSize,\n                realSize: RowOrColumn.getElementDimensionSize(contentItem.element, this._dimension) - headerSize,\n            });\n            if (collapsed) {\n                RowOrColumn.setElementDimensionSize(contentItem.childElementContainer, this._dimension, 0);\n            }\n        }\n        contentItem.element.classList.toggle(\"lm_docked\" /* Docked */, contentItem.docker.docked);\n        this.updateSize();\n        this.emitBaseBubblingEvent('stateChanged');\n        this.validateDocking();\n    }\n    /**\n     * Validate if row or column has ability to dock\n     * @internal\n     */\n    validateDocking() {\n        var _a;\n        const can = this.contentItems.length - this.calculateDockedCount() > 1;\n        for (let i = 0; i < this.contentItems.length; ++i) {\n            const contentItem = this.contentItems[i];\n            if (contentItem instanceof stack_1.Stack) {\n                contentItem.setDockable((_a = this.isDocked(i)) !== null && _a !== void 0 ? _a : can);\n                contentItem.setRowColumnClosable(can);\n            }\n        }\n    }\n    /**\n     * Invoked recursively by the layout manager. ContentItem.init appends\n     * the contentItem's DOM elements to the container, RowOrColumn init adds splitters\n     * in between them\n     * @internal\n     */\n    init() {\n        if (this.isInitialised === true)\n            return;\n        this.updateNodeSize();\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this._childElementContainer.appendChild(this.contentItems[i].element);\n        }\n        super.init();\n        for (let i = 0; i < this.contentItems.length - 1; i++) {\n            this.contentItems[i].element.insertAdjacentElement('afterend', this.createSplitter(i).element);\n        }\n        for (let i = 0; i < this.contentItems.length; i++) {\n            const contentItem = this.contentItems[i];\n            // was previously\n            // if (this.contentItems[i]._header && this.contentItems[i]._header.docked)\n            // I think this.contentItems[i]._header.docked did not exist (and was always undefined) so the below may be wrong\n            if (contentItem instanceof stack_1.Stack && contentItem.docker.docked) {\n                this.dock(contentItem, true, true);\n            }\n        }\n        this.initContentItems();\n    }\n    toConfig() {\n        const result = {\n            type: this.type,\n            content: this.calculateConfigContent(),\n            width: this.width,\n            minWidth: this.minWidth,\n            height: this.height,\n            minHeight: this.minHeight,\n            id: this.id,\n            isClosable: this.isClosable,\n        };\n        return result;\n    }\n    /** @internal */\n    setParent(parent) {\n        this._rowOrColumnParent = parent;\n        super.setParent(parent);\n    }\n    /** @internal */\n    updateNodeSize() {\n        if (this.contentItems.length > 0) {\n            this.calculateRelativeSizes();\n            this.setAbsoluteSizes();\n        }\n        this.emitBaseBubblingEvent('stateChanged');\n        this.emit('resize');\n    }\n    /**\n     * Turns the relative sizes calculated by calculateRelativeSizes into\n     * absolute pixel values and applies them to the children's DOM elements\n     *\n     * Assigns additional pixels to counteract Math.floor\n     * @internal\n     */\n    setAbsoluteSizes() {\n        const sizeData = this.calculateAbsoluteSizes();\n        for (let i = 0; i < this.contentItems.length; i++) {\n            if (sizeData.additionalPixel - i > 0) {\n                sizeData.itemSizes[i]++;\n            }\n            if (this._isColumn) {\n                utils_1.setElementWidth(this.contentItems[i].element, sizeData.totalWidth);\n                utils_1.setElementHeight(this.contentItems[i].element, sizeData.itemSizes[i]);\n            }\n            else {\n                utils_1.setElementWidth(this.contentItems[i].element, sizeData.itemSizes[i]);\n                utils_1.setElementHeight(this.contentItems[i].element, sizeData.totalHeight);\n            }\n        }\n    }\n    /**\n     * Calculates the absolute sizes of all of the children of this Item.\n     * @returns Set with absolute sizes and additional pixels.\n     * @internal\n     */\n    calculateAbsoluteSizes() {\n        const totalSplitterSize = (this.contentItems.length - 1) * this._splitterSize;\n        const headerSize = this.layoutManager.layoutConfig.dimensions.headerHeight;\n        let { width: totalWidth, height: totalHeight } = utils_1.getElementWidthAndHeight(this.element);\n        if (this._isColumn) {\n            totalHeight -= totalSplitterSize;\n        }\n        else {\n            totalWidth -= totalSplitterSize;\n        }\n        for (let i = 0; i < this.contentItems.length; i++) {\n            if (this.isDocked(i)) {\n                if (this._isColumn) {\n                    totalHeight -= headerSize - this._splitterSize;\n                }\n                else {\n                    totalWidth -= headerSize - this._splitterSize;\n                }\n            }\n        }\n        let totalAssigned = 0;\n        const itemSizes = [];\n        for (let i = 0; i < this.contentItems.length; i++) {\n            let itemSize;\n            if (this._isColumn) {\n                itemSize = Math.floor(totalHeight * (this.contentItems[i].height / 100));\n            }\n            else {\n                itemSize = Math.floor(totalWidth * (this.contentItems[i].width / 100));\n            }\n            if (this.isDocked(i))\n                itemSize = headerSize;\n            totalAssigned += itemSize;\n            itemSizes.push(itemSize);\n        }\n        const additionalPixel = Math.floor((this._isColumn ? totalHeight : totalWidth) - totalAssigned);\n        return {\n            itemSizes: itemSizes,\n            additionalPixel: additionalPixel,\n            totalWidth: totalWidth,\n            totalHeight: totalHeight\n        };\n    }\n    /**\n     * Calculates the relative sizes of all children of this Item. The logic\n     * is as follows:\n     *\n     * - Add up the total size of all items that have a configured size\n     *\n     * - If the total == 100 (check for floating point errors)\n     *        Excellent, job done\n     *\n     * - If the total is \\> 100,\n     *        set the size of items without set dimensions to 1/3 and add this to the total\n     *        set the size off all items so that the total is hundred relative to their original size\n     *\n     * - If the total is \\< 100\n     *        If there are items without set dimensions, distribute the remainder to 100 evenly between them\n     *        If there are no items without set dimensions, increase all items sizes relative to\n     *        their original size so that they add up to 100\n     *\n     * @internal\n     */\n    calculateRelativeSizes() {\n        let total = 0;\n        const itemsWithoutSetDimension = [];\n        for (let i = 0; i < this.contentItems.length; i++) {\n            if (this.contentItems[i][this._dimension] !== undefined) {\n                total += this.contentItems[i][this._dimension];\n            }\n            else {\n                itemsWithoutSetDimension.push(this.contentItems[i]);\n            }\n        }\n        /**\n         * Everything adds up to hundred, all good :-)\n         */\n        if (Math.round(total) === 100) {\n            this.respectMinItemWidth();\n            return;\n        }\n        /**\n         * Allocate the remaining size to the items without a set dimension\n         */\n        if (Math.round(total) < 100 && itemsWithoutSetDimension.length > 0) {\n            for (let i = 0; i < itemsWithoutSetDimension.length; i++) {\n                itemsWithoutSetDimension[i][this._dimension] = (100 - total) / itemsWithoutSetDimension.length;\n            }\n            this.respectMinItemWidth();\n            return;\n        }\n        /**\n         * If the total is > 100, but there are also items without a set dimension left, assing 50\n         * as their dimension and add it to the total\n         *\n         * This will be reset in the next step\n         */\n        if (Math.round(total) > 100) {\n            for (let i = 0; i < itemsWithoutSetDimension.length; i++) {\n                itemsWithoutSetDimension[i][this._dimension] = 50;\n                total += 50;\n            }\n        }\n        /**\n         * Set every items size relative to 100 relative to its size to total\n         */\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this.contentItems[i][this._dimension] = (this.contentItems[i][this._dimension] / total) * 100;\n        }\n        this.respectMinItemWidth();\n    }\n    /**\n     * Adjusts the column widths to respect the dimensions minItemWidth if set.\n     * @internal\n     */\n    respectMinItemWidth() {\n        const minItemWidth = this.layoutManager.layoutConfig.dimensions.minItemWidth;\n        let totalOverMin = 0;\n        let totalUnderMin = 0;\n        const entriesOverMin = [];\n        const allEntries = [];\n        if (this._isColumn || !minItemWidth || this.contentItems.length <= 1) {\n            return;\n        }\n        const sizeData = this.calculateAbsoluteSizes();\n        /**\n         * Figure out how much we are under the min item size total and how much room we have to use.\n         */\n        for (let i = 0; i < sizeData.itemSizes.length; i++) {\n            const itemSize = sizeData.itemSizes[i];\n            let entry;\n            if (itemSize < minItemWidth) {\n                totalUnderMin += minItemWidth - itemSize;\n                entry = {\n                    width: minItemWidth\n                };\n            }\n            else {\n                totalOverMin += itemSize - minItemWidth;\n                entry = {\n                    width: itemSize\n                };\n                entriesOverMin.push(entry);\n            }\n            allEntries.push(entry);\n        }\n        /**\n         * If there is nothing under min, or there is not enough over to make up the difference, do nothing.\n         */\n        if (totalUnderMin === 0 || totalUnderMin > totalOverMin) {\n            return;\n        }\n        /**\n         * Evenly reduce all columns that are over the min item width to make up the difference.\n         */\n        const reducePercent = totalUnderMin / totalOverMin;\n        let remainingWidth = totalUnderMin;\n        for (let i = 0; i < entriesOverMin.length; i++) {\n            const entry = entriesOverMin[i];\n            const reducedWidth = Math.round((entry.width - minItemWidth) * reducePercent);\n            remainingWidth -= reducedWidth;\n            entry.width -= reducedWidth;\n        }\n        /**\n         * Take anything remaining from the last item.\n         */\n        if (remainingWidth !== 0) {\n            allEntries[allEntries.length - 1].width -= remainingWidth;\n        }\n        /**\n         * Set every items size relative to 100 relative to its size to total\n         */\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this.contentItems[i].width = (allEntries[i].width / sizeData.totalWidth) * 100;\n        }\n    }\n    /**\n     * Instantiates a new Splitter, binds events to it and adds\n     * it to the array of splitters at the position specified as the index argument\n     *\n     * What it doesn't do though is append the splitter to the DOM\n     *\n     * @param index - The position of the splitter\n     *\n     * @returns\n     * @internal\n     */\n    createSplitter(index) {\n        const splitter = new splitter_1.Splitter(this._isColumn, this._splitterSize, this._splitterGrabSize);\n        splitter.on('drag', (offsetX, offsetY) => this.onSplitterDrag(splitter, offsetX, offsetY));\n        splitter.on('dragStop', () => this.onSplitterDragStop(splitter));\n        splitter.on('dragStart', () => this.onSplitterDragStart(splitter));\n        this._splitter.splice(index, 0, splitter);\n        return splitter;\n    }\n    /**\n     * Locates the instance of Splitter in the array of\n     * registered splitters and returns a map containing the contentItem\n     * before and after the splitters, both of which are affected if the\n     * splitter is moved\n     *\n     * @returns A map of contentItems that the splitter affects\n     * @internal\n     */\n    getItemsForSplitter(splitter) {\n        const index = this._splitter.indexOf(splitter);\n        return {\n            before: this.contentItems[index],\n            after: this.contentItems[index + 1]\n        };\n    }\n    /** @internal */\n    isDocked(index) {\n        if (index >= this.contentItems.length) {\n            return false;\n        }\n        else {\n            const contentItem = this.contentItems[index];\n            if (contentItem instanceof stack_1.Stack) {\n                return contentItem.docker.docked;\n            }\n            else {\n                return false;\n            }\n        }\n    }\n    /** @internal */\n    calculateDockedCount() {\n        let count = 0;\n        for (let i = 0; i < this.contentItems.length; ++i)\n            if (this.isDocked(i))\n                count++;\n        return count;\n    }\n    /**\n     * Gets the minimum dimensions for the given item configuration array\n     * @internal\n     */\n    getMinimumDimensions(arr) {\n        var _a, _b;\n        let minWidth = 0;\n        let minHeight = 0;\n        for (let i = 0; i < arr.length; ++i) {\n            minWidth = Math.max((_a = arr[i].minWidth) !== null && _a !== void 0 ? _a : 0, minWidth);\n            minHeight = Math.max((_b = arr[i].minHeight) !== null && _b !== void 0 ? _b : 0, minHeight);\n        }\n        return {\n            horizontal: minWidth,\n            vertical: minHeight\n        };\n    }\n    /**\n     * Invoked when a splitter's dragListener fires dragStart. Calculates the splitters\n     * movement area once (so that it doesn't need calculating on every mousemove event)\n     * @internal\n     */\n    onSplitterDragStart(splitter) {\n        const items = this.getItemsForSplitter(splitter);\n        const minSize = this.layoutManager.layoutConfig.dimensions[this._isColumn ? 'minItemHeight' : 'minItemWidth'];\n        const beforeMinDim = this.getMinimumDimensions(items.before.contentItems);\n        const beforeMinSize = this._isColumn ? beforeMinDim.vertical : beforeMinDim.horizontal;\n        const afterMinDim = this.getMinimumDimensions(items.after.contentItems);\n        const afterMinSize = this._isColumn ? afterMinDim.vertical : afterMinDim.horizontal;\n        this._splitterPosition = 0;\n        this._splitterMinPosition = -1 * (utils_1.pixelsToNumber(items.before.element.style[this._dimension]) - (beforeMinSize || minSize));\n        this._splitterMaxPosition = utils_1.pixelsToNumber(items.after.element.style[this._dimension]) - (afterMinSize || minSize);\n    }\n    /**\n     * Invoked when a splitter's DragListener fires drag. Updates the splitters DOM position,\n     * but not the sizes of the elements the splitter controls in order to minimize resize events\n     *\n     * @param splitter -\n     * @param offsetX - Relative pixel values to the splitters original position. Can be negative\n     * @param offsetY - Relative pixel values to the splitters original position. Can be negative\n     * @internal\n     */\n    onSplitterDrag(splitter, offsetX, offsetY) {\n        const offset = this._isColumn ? offsetY : offsetX;\n        if (this._splitterMinPosition === null || this._splitterMaxPosition === null) {\n            throw new internal_error_1.UnexpectedNullError('ROCOSD59226');\n        }\n        else {\n            if (offset > this._splitterMinPosition && offset < this._splitterMaxPosition) {\n                this._splitterPosition = offset;\n                const offsetPixels = utils_1.numberToPixels(offset);\n                if (this._isColumn) {\n                    splitter.element.style.top = offsetPixels;\n                }\n                else {\n                    splitter.element.style.left = offsetPixels;\n                }\n            }\n        }\n    }\n    /**\n     * Invoked when a splitter's DragListener fires dragStop. Resets the splitters DOM position,\n     * and applies the new sizes to the elements before and after the splitter and their children\n     * on the next animation frame\n     * @internal\n     */\n    onSplitterDragStop(splitter) {\n        if (this._splitterPosition === null) {\n            throw new internal_error_1.UnexpectedNullError('ROCOSDS66932');\n        }\n        else {\n            const items = this.getItemsForSplitter(splitter);\n            const sizeBefore = utils_1.pixelsToNumber(items.before.element.style[this._dimension]);\n            const sizeAfter = utils_1.pixelsToNumber(items.after.element.style[this._dimension]);\n            const splitterPositionInRange = (this._splitterPosition + sizeBefore) / (sizeBefore + sizeAfter);\n            const totalRelativeSize = items.before[this._dimension] + items.after[this._dimension];\n            items.before[this._dimension] = splitterPositionInRange * totalRelativeSize;\n            items.after[this._dimension] = (1 - splitterPositionInRange) * totalRelativeSize;\n            splitter.element.style.top = utils_1.numberToPixels(0);\n            splitter.element.style.left = utils_1.numberToPixels(0);\n            globalThis.requestAnimationFrame(() => this.updateSize());\n        }\n    }\n}\nexports.RowOrColumn = RowOrColumn;\n/** @public */\n(function (RowOrColumn) {\n    /** @internal */\n    function getElementDimensionSize(element, dimension) {\n        if (dimension === 'width') {\n            return utils_1.getElementWidth(element);\n        }\n        else {\n            return utils_1.getElementHeight(element);\n        }\n    }\n    RowOrColumn.getElementDimensionSize = getElementDimensionSize;\n    /** @internal */\n    function setElementDimensionSize(element, dimension, value) {\n        if (dimension === 'width') {\n            return utils_1.setElementWidth(element, value);\n        }\n        else {\n            return utils_1.setElementHeight(element, value);\n        }\n    }\n    RowOrColumn.setElementDimensionSize = setElementDimensionSize;\n    /** @internal */\n    function createElement(document, isColumn) {\n        const element = document.createElement('div');\n        element.classList.add(\"lm_item\" /* Item */);\n        if (isColumn) {\n            element.classList.add(\"lm_column\" /* Column */);\n        }\n        else {\n            element.classList.add(\"lm_row\" /* Row */);\n        }\n        return element;\n    }\n    RowOrColumn.createElement = createElement;\n})(RowOrColumn = exports.RowOrColumn || (exports.RowOrColumn = {}));\n//# sourceMappingURL=row-or-column.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","RowOrColumn","config_1","splitter_1","internal_error_1","types_1","utils_1","content_item_1","stack_1","ContentItem","isColumn","layoutManager","config","_rowOrColumnParent","createElement","document","_splitter","isRow","_childElementContainer","element","_splitterSize","layoutConfig","dimensions","borderWidth","_splitterGrabSize","borderGrabWidth","_dimension","_isColumn","_splitterMaxPosition","_splitterMinPosition","_splitterPosition","type","ItemType","row","column","_configType","AssertError","componentType","componentState","title","index","newItem","itemConfig","addItem","createdItem","contentItems","isStack","ItemConfig","isComponent","checkMinimiseMaximisedStack","resolvedItemConfig","resolve","contentItem","createAndInitContentItem","addChild","suspendResize","undefined","length","splitterElement","createSplitter","Math","max","insertAdjacentElement","isDocked","setElementDisplayVisibility","appendChild","newItemSize","emitBaseBubblingEvent","i","itemSize","updateSize","validateDocking","keepChild","removedItemSize","indexOf","splitterIndex","Error","destroy","splice","dockedCount","calculateDockedCount","removeChild","isClosable","childItem","replaceChild","oldChild","newChild","size","updateNodeSize","updateContentItemsSize","mode","collapsed","headerSize","header","show","headerHeight","docker","docked","style","display","setUndocked","required","autoside","first","Side","top","last","bottom","left","right","headerSide","positionHeader","setDocked","dimension","realSize","getElementDimensionSize","setElementDimensionSize","childElementContainer","classList","toggle","_a","can","Stack","setDockable","setRowColumnClosable","isInitialised","init","dock","initContentItems","result","content","calculateConfigContent","width","minWidth","height","minHeight","id","parent","setParent","calculateRelativeSizes","setAbsoluteSizes","emit","sizeData","calculateAbsoluteSizes","additionalPixel","itemSizes","setElementWidth","totalWidth","setElementHeight","totalHeight","totalSplitterSize","getElementWidthAndHeight","totalAssigned","floor","push","total","itemsWithoutSetDimension","round","respectMinItemWidth","minItemWidth","totalOverMin","totalUnderMin","entriesOverMin","allEntries","entry","reducePercent","reducedWidth","remainingWidth","splitter","Splitter","on","offsetX","offsetY","onSplitterDrag","onSplitterDragStop","onSplitterDragStart","before","after","count","arr","_b","horizontal","vertical","items","getItemsForSplitter","minSize","beforeMinDim","getMinimumDimensions","beforeMinSize","afterMinDim","afterMinSize","pixelsToNumber","offset","UnexpectedNullError","offsetPixels","numberToPixels","sizeBefore","sizeAfter","splitterPositionInRange","totalRelativeSize","globalThis","requestAnimationFrame","getElementWidth","getElementHeight","add"]
}
