{
"version":3,
"file":"module$node_modules$golden_layout$dist$cjs$ts$layout_manager.js",
"lineCount":59,
"mappings":"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",
"sources":["node_modules/golden-layout/dist/cjs/ts/layout-manager.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$golden_layout$dist$cjs$ts$layout_manager\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LayoutManager = void 0;\nconst config_1 = require(\"./config/config\");\nconst resolved_config_1 = require(\"./config/resolved-config\");\nconst browser_popout_1 = require(\"./controls/browser-popout\");\nconst drag_proxy_1 = require(\"./controls/drag-proxy\");\nconst drag_source_1 = require(\"./controls/drag-source\");\nconst drop_target_indicator_1 = require(\"./controls/drop-target-indicator\");\nconst transition_indicator_1 = require(\"./controls/transition-indicator\");\nconst external_error_1 = require(\"./errors/external-error\");\nconst internal_error_1 = require(\"./errors/internal-error\");\nconst component_item_1 = require(\"./items/component-item\");\nconst content_item_1 = require(\"./items/content-item\");\nconst ground_item_1 = require(\"./items/ground-item\");\nconst row_or_column_1 = require(\"./items/row-or-column\");\nconst stack_1 = require(\"./items/stack\");\nconst config_minifier_1 = require(\"./utils/config-minifier\");\nconst event_emitter_1 = require(\"./utils/event-emitter\");\nconst event_hub_1 = require(\"./utils/event-hub\");\nconst i18n_strings_1 = require(\"./utils/i18n-strings\");\nconst types_1 = require(\"./utils/types\");\nconst utils_1 = require(\"./utils/utils\");\n/**\n * The main class that will be exposed as GoldenLayout.\n */\n/** @public */\nclass LayoutManager extends event_emitter_1.EventEmitter {\n    /**\n    * @param container - A Dom HTML element. Defaults to body\n    * @internal\n    */\n    constructor(parameters) {\n        super();\n        /** @internal */\n        this._isFullPage = false;\n        /** @internal */\n        this._isInitialised = false;\n        /** @internal */\n        this._groundItem = undefined;\n        /** @internal */\n        this._openPopouts = [];\n        /** @internal */\n        this._dropTargetIndicator = null;\n        /** @internal */\n        this._transitionIndicator = null;\n        /** @internal */\n        this._componentTypes = {};\n        /** @internal */\n        this._itemAreas = [];\n        /** @internal */\n        this._maximisePlaceholder = LayoutManager.createMaximisePlaceElement(document);\n        /** @internal */\n        this._tabDropPlaceholder = LayoutManager.createTabDropPlaceholderElement(document);\n        /** @internal */\n        this._dragSources = [];\n        /** @internal */\n        this._updatingColumnsResponsive = false;\n        /** @internal */\n        this._firstLoad = true;\n        /** @internal */\n        this._eventHub = new event_hub_1.EventHub(this);\n        /** @internal */\n        this._width = null;\n        /** @internal */\n        this._height = null;\n        /** @internal */\n        this._windowResizeListener = () => this.processResizeWithDebounce();\n        /** @internal */\n        this._windowUnloadListener = () => this.onUnload();\n        /** @internal */\n        this._maximisedStackBeforeDestroyedListener = (ev) => this.cleanupBeforeMaximisedStackDestroyed(ev);\n        let layoutConfig = parameters.layoutConfig;\n        if (layoutConfig === undefined) {\n            layoutConfig = resolved_config_1.ResolvedLayoutConfig.createDefault();\n        }\n        this.layoutConfig = layoutConfig;\n        this.isSubWindow = parameters.isSubWindow;\n        i18n_strings_1.I18nStrings.checkInitialise();\n        config_minifier_1.ConfigMinifier.checkInitialise();\n        if (parameters.containerElement !== undefined) {\n            this._containerElement = parameters.containerElement;\n        }\n    }\n    get container() { return this._containerElement; }\n    get isInitialised() { return this._isInitialised; }\n    /** @internal */\n    get groundItem() { return this._groundItem; }\n    /** @internal @deprecated use {@link (LayoutManager:class).groundItem} instead */\n    get root() { return this._groundItem; }\n    get openPopouts() { return this._openPopouts; }\n    /** @internal */\n    get dropTargetIndicator() { return this._dropTargetIndicator; }\n    /** @internal */\n    get transitionIndicator() { return this._transitionIndicator; }\n    get width() { return this._width; }\n    get height() { return this._height; }\n    /** @internal */\n    get eventHub() { return this._eventHub; }\n    get rootItem() {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot access rootItem before init');\n        }\n        else {\n            const groundContentItems = this._groundItem.contentItems;\n            if (groundContentItems.length === 0) {\n                return undefined;\n            }\n            else {\n                return this._groundItem.contentItems[0];\n            }\n        }\n    }\n    get focusedComponentItem() { return this._focusedComponentItem; }\n    /** @internal */\n    get tabDropPlaceholder() { return this._tabDropPlaceholder; }\n    get maximisedStack() { return this._maximisedStack; }\n    /**\n     * Destroys the LayoutManager instance itself as well as every ContentItem\n     * within it. After this is called nothing should be left of the LayoutManager.\n     */\n    destroy() {\n        if (this._isInitialised) {\n            if (this.layoutConfig.settings.closePopoutsOnUnload === true) {\n                for (let i = 0; i < this._openPopouts.length; i++) {\n                    this._openPopouts[i].close();\n                }\n            }\n            if (this._isFullPage) {\n                globalThis.removeEventListener('resize', this._windowResizeListener);\n            }\n            globalThis.removeEventListener('unload', this._windowUnloadListener);\n            globalThis.removeEventListener('beforeunload', this._windowUnloadListener);\n            if (this._groundItem !== undefined) {\n                this._groundItem.destroy();\n            }\n            this._tabDropPlaceholder.remove();\n            if (this._dropTargetIndicator !== null) {\n                this._dropTargetIndicator.destroy();\n            }\n            if (this._transitionIndicator !== null) {\n                this._transitionIndicator.destroy();\n            }\n            this._eventHub.destroy();\n            for (const dragSource of this._dragSources) {\n                dragSource.destroy();\n            }\n            this._dragSources = [];\n            this.getComponentEvent = undefined;\n            this.releaseComponentEvent = undefined;\n            this._isInitialised = false;\n        }\n    }\n    /**\n     * Takes a GoldenLayout configuration object and\n     * replaces its keys and values recursively with\n     * one letter codes\n     * @deprecated use {@link (ResolvedLayoutConfig:namespace).minifyConfig} instead\n     */\n    minifyConfig(config) {\n        return resolved_config_1.ResolvedLayoutConfig.minifyConfig(config);\n    }\n    /**\n     * Takes a configuration Object that was previously minified\n     * using minifyConfig and returns its original version\n     * @deprecated use {@link (ResolvedLayoutConfig:namespace).unminifyConfig} instead\n     */\n    unminifyConfig(config) {\n        return resolved_config_1.ResolvedLayoutConfig.unminifyConfig(config);\n    }\n    /**\n     * Register a new component type with the layout manager.\n     *\n     * @deprecated See {@link https://stackoverflow.com/questions/40922531/how-to-check-if-a-javascript-function-is-a-constructor}\n     * instead use {@link (LayoutManager:class).registerComponentConstructor}\n     * or {@link (LayoutManager:class).registerComponentFactoryFunction}\n     */\n    registerComponent(name, componentConstructorOrFactoryFtn) {\n        if (typeof componentConstructorOrFactoryFtn !== 'function') {\n            throw new external_error_1.ApiError('registerComponent() componentConstructorOrFactoryFtn parameter is not a function');\n        }\n        else {\n            if (componentConstructorOrFactoryFtn.hasOwnProperty('prototype')) {\n                const componentConstructor = componentConstructorOrFactoryFtn;\n                this.registerComponentConstructor(name, componentConstructor);\n            }\n            else {\n                const componentFactoryFtn = componentConstructorOrFactoryFtn;\n                this.registerComponentFactoryFunction(name, componentFactoryFtn);\n            }\n        }\n    }\n    /**\n     * Register a new component type with the layout manager.\n     */\n    registerComponentConstructor(typeName, componentConstructor) {\n        if (typeof componentConstructor !== 'function') {\n            throw new Error(i18n_strings_1.i18nStrings[1 /* PleaseRegisterAConstructorFunction */]);\n        }\n        if (this._componentTypes[typeName] !== undefined) {\n            throw new Error(`${i18n_strings_1.i18nStrings[2 /* ComponentIsAlreadyRegistered */]}: ${typeName}`);\n        }\n        this._componentTypes[typeName] = {\n            constructor: componentConstructor,\n            factoryFunction: undefined,\n        };\n    }\n    /**\n     * Register a new component with the layout manager.\n     */\n    registerComponentFactoryFunction(typeName, componentFactoryFunction) {\n        if (typeof componentFactoryFunction !== 'function') {\n            throw new Error('Please register a constructor function');\n        }\n        if (this._componentTypes[typeName] !== undefined) {\n            throw new Error('Component ' + typeName + ' is already registered');\n        }\n        this._componentTypes[typeName] = {\n            constructor: undefined,\n            factoryFunction: componentFactoryFunction,\n        };\n    }\n    /**\n     * Register a component function with the layout manager. This function should\n     * return a constructor for a component based on a config.\n     * This function will be called if a component type with the required name is not already registered.\n     * It is recommended that applications use the {@link (LayoutManager:class).getComponentEvent} and\n     * {@link (LayoutManager:class).releaseComponentEvent} instead of registering a constructor callback\n     * @deprecated use {@link (LayoutManager:class).registerGetComponentConstructorCallback}\n     */\n    registerComponentFunction(callback) {\n        this.registerGetComponentConstructorCallback(callback);\n    }\n    /**\n     * Register a callback closure with the layout manager which supplies a Component Constructor.\n     * This callback should return a constructor for a component based on a config.\n     * This function will be called if a component type with the required name is not already registered.\n     * It is recommended that applications use the {@link (LayoutManager:class).getComponentEvent} and\n     * {@link (LayoutManager:class).releaseComponentEvent} instead of registering a constructor callback\n     */\n    registerGetComponentConstructorCallback(callback) {\n        if (typeof callback !== 'function') {\n            throw new Error('Please register a callback function');\n        }\n        if (this._getComponentConstructorFtn !== undefined) {\n            console.warn('Multiple component functions are being registered.  Only the final registered function will be used.');\n        }\n        this._getComponentConstructorFtn = callback;\n    }\n    getRegisteredComponentTypeNames() {\n        return Object.keys(this._componentTypes);\n    }\n    /**\n     * Returns a previously registered component instantiator.  Attempts to utilize registered\n     * component type by first, then falls back to the component constructor callback function (if registered).\n     * If neither gets an instantiator, then returns `undefined`.\n     * Note that `undefined` will return if config.componentType is not a string\n     *\n     * @param config - The item config\n     * @public\n     */\n    getComponentInstantiator(config) {\n        let instantiator;\n        const typeName = resolved_config_1.ResolvedComponentItemConfig.resolveComponentTypeName(config);\n        if (typeName !== undefined) {\n            instantiator = this._componentTypes[typeName];\n        }\n        if (instantiator === undefined) {\n            if (this._getComponentConstructorFtn !== undefined) {\n                instantiator = {\n                    constructor: this._getComponentConstructorFtn(config),\n                    factoryFunction: undefined,\n                };\n            }\n        }\n        return instantiator;\n    }\n    /** @internal */\n    getComponent(container, itemConfig) {\n        let instantiator;\n        const typeName = resolved_config_1.ResolvedComponentItemConfig.resolveComponentTypeName(itemConfig);\n        if (typeName !== undefined) {\n            instantiator = this._componentTypes[typeName];\n        }\n        if (instantiator === undefined) {\n            if (this._getComponentConstructorFtn !== undefined) {\n                instantiator = {\n                    constructor: this._getComponentConstructorFtn(itemConfig),\n                    factoryFunction: undefined,\n                };\n            }\n        }\n        let component;\n        if (instantiator !== undefined) {\n            // handle case where component is obtained by name or component constructor callback\n            let componentState;\n            if (itemConfig.componentState === undefined) {\n                componentState = undefined;\n            }\n            else {\n                // make copy\n                componentState = utils_1.deepExtendValue({}, itemConfig.componentState);\n            }\n            // This next (commented out) if statement is a bad hack. Looks like someone wanted the component name passed\n            // to the component's constructor.  The application really should have put this into the state itself.\n            // If an application needs this information in the constructor, it should now use the getComponentEvent.\n            // if (typeof componentState === 'object' && componentState !== null) {\n            //     (componentState as Record<string, unknown>).componentName = itemConfig.componentName;\n            // }\n            const componentConstructor = instantiator.constructor;\n            if (componentConstructor !== undefined) {\n                component = new componentConstructor(container, componentState);\n            }\n            else {\n                const factoryFunction = instantiator.factoryFunction;\n                if (factoryFunction !== undefined) {\n                    component = factoryFunction(container, componentState);\n                }\n                else {\n                    throw new internal_error_1.AssertError('LMGC10008');\n                }\n            }\n        }\n        else {\n            if (this.getComponentEvent !== undefined) {\n                component = this.getComponentEvent(container, itemConfig);\n            }\n            else {\n                throw new Error();\n            }\n        }\n        return component;\n    }\n    /** @internal */\n    releaseComponent(container, component) {\n        if (this.releaseComponentEvent !== undefined) {\n            this.releaseComponentEvent(container, component);\n        }\n    }\n    /**\n     * Called from GoldenLayout class. Finishes of init\n     * @internal\n     */\n    init() {\n        this.setContainer();\n        this._dropTargetIndicator = new drop_target_indicator_1.DropTargetIndicator( /*this.container*/);\n        this._transitionIndicator = new transition_indicator_1.TransitionIndicator();\n        this.updateSizeFromContainer();\n        const layoutConfig = this.layoutConfig;\n        this._groundItem = new ground_item_1.GroundItem(this, layoutConfig.root, this._containerElement);\n        this._groundItem.init();\n        this.checkLoadedLayoutMaximiseItem();\n        this.bindEvents();\n        this._isInitialised = true;\n        this.adjustColumnsResponsive();\n        this.emit('initialised');\n    }\n    /**\n     * Loads a new layout\n     * @param layoutConfig - New layout to be loaded\n     */\n    loadLayout(layoutConfig) {\n        if (!this.isInitialised) {\n            // In case application not correctly using legacy constructor\n            throw new Error('GoldenLayout: Need to call init() if LayoutConfig with defined root passed to constructor');\n        }\n        else {\n            if (this._groundItem === undefined) {\n                throw new internal_error_1.UnexpectedUndefinedError('LMLL11119');\n            }\n            else {\n                this.layoutConfig = config_1.LayoutConfig.resolve(layoutConfig);\n                this._groundItem.loadRoot(this.layoutConfig.root);\n                this.checkLoadedLayoutMaximiseItem();\n                this.adjustColumnsResponsive();\n            }\n        }\n    }\n    /**\n     * Creates a layout configuration object based on the the current state\n     *\n     * @public\n     * @returns GoldenLayout configuration\n     */\n    saveLayout() {\n        if (this._isInitialised === false) {\n            throw new Error('Can\\'t create config, layout not yet initialised');\n        }\n        else {\n            // if (root !== undefined && !(root instanceof ContentItem)) {\n            //     throw new Error('Root must be a ContentItem');\n            // }\n            /*\n            * Content\n            */\n            if (this._groundItem === undefined) {\n                throw new internal_error_1.UnexpectedUndefinedError('LMTC18244');\n            }\n            else {\n                const groundContent = this._groundItem.calculateConfigContent();\n                let rootItemConfig;\n                if (groundContent.length !== 1) {\n                    rootItemConfig = undefined;\n                }\n                else {\n                    rootItemConfig = groundContent[0];\n                }\n                /*\n                * Retrieve config for subwindows\n                */\n                this.reconcilePopoutWindows();\n                const openPopouts = [];\n                for (let i = 0; i < this._openPopouts.length; i++) {\n                    openPopouts.push(this._openPopouts[i].toConfig());\n                }\n                const config = {\n                    root: rootItemConfig,\n                    openPopouts,\n                    settings: resolved_config_1.ResolvedLayoutConfig.Settings.createCopy(this.layoutConfig.settings),\n                    dimensions: resolved_config_1.ResolvedLayoutConfig.Dimensions.createCopy(this.layoutConfig.dimensions),\n                    header: resolved_config_1.ResolvedLayoutConfig.Header.createCopy(this.layoutConfig.header),\n                    resolved: true,\n                };\n                return config;\n            }\n        }\n    }\n    /**\n     * @deprecated Use {@link (LayoutManager:class).saveLayout}\n     */\n    toConfig() {\n        return this.saveLayout();\n    }\n    /**\n     * Adds a new ComponentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param componentTypeName - Name of component type to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @returns New ComponentItem created.\n     */\n    newComponent(componentType, componentState, title) {\n        const componentItem = this.newComponentAtLocation(componentType, componentState, title);\n        if (componentItem === undefined) {\n            throw new internal_error_1.AssertError('LMNC65588');\n        }\n        else {\n            return componentItem;\n        }\n    }\n    /**\n     * Adds a ComponentItem at the first valid selector location.\n     * @param componentTypeName - Name of component type to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @param locationSelectors - Array of location selectors used to find location in layout where component\n     * will be added. First location in array which is valid will be used. If locationSelectors is undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used\n     * @returns New ComponentItem created or undefined if no valid location selector was in array.\n     */\n    newComponentAtLocation(componentType, componentState, title, locationSelectors) {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        }\n        else {\n            const location = this.addComponentAtLocation(componentType, componentState, title, locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            }\n            else {\n                const createdItem = location.parentItem.contentItems[location.index];\n                if (!content_item_1.ContentItem.isComponentItem(createdItem)) {\n                    throw new internal_error_1.AssertError('LMNC992877533');\n                }\n                else {\n                    return createdItem;\n                }\n            }\n        }\n    }\n    /**\n     * Adds a new ComponentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param componentType - Type of component to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @returns Location of new ComponentItem created.\n     */\n    addComponent(componentType, componentState, title) {\n        const location = this.addComponentAtLocation(componentType, componentState, title);\n        if (location === undefined) {\n            throw new internal_error_1.AssertError('LMAC99943');\n        }\n        else {\n            return location;\n        }\n    }\n    /**\n     * Adds a ComponentItem at the first valid selector location.\n     * @param componentType - Type of component to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where component\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns Location of new ComponentItem created or undefined if no valid location selector was in array.\n     */\n    addComponentAtLocation(componentType, componentState, title, locationSelectors) {\n        const itemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.addItemAtLocation(itemConfig, locationSelectors);\n    }\n    /**\n     * Adds a new ContentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @returns New ContentItem created.\n    */\n    newItem(itemConfig) {\n        const contentItem = this.newItemAtLocation(itemConfig);\n        if (contentItem === undefined) {\n            throw new internal_error_1.AssertError('LMNC65588');\n        }\n        else {\n            return contentItem;\n        }\n    }\n    /**\n     * Adds a new child ContentItem under the root ContentItem.  If a root does not exist, then create root ContentItem instead\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where ContentItem\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns New ContentItem created or undefined if no valid location selector was in array. */\n    newItemAtLocation(itemConfig, locationSelectors) {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        }\n        else {\n            const location = this.addItemAtLocation(itemConfig, locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            }\n            else {\n                const createdItem = location.parentItem.contentItems[location.index];\n                return createdItem;\n            }\n        }\n    }\n    /**\n     * Adds a new ContentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added.\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @returns Location of new ContentItem created. */\n    addItem(itemConfig) {\n        const location = this.addItemAtLocation(itemConfig);\n        if (location === undefined) {\n            throw new internal_error_1.AssertError('LMAI99943');\n        }\n        else {\n            return location;\n        }\n    }\n    /**\n     * Adds a ContentItem at the first valid selector location.\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where ContentItem\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns Location of new ContentItem created or undefined if no valid location selector was in array. */\n    addItemAtLocation(itemConfig, locationSelectors) {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        }\n        else {\n            if (locationSelectors === undefined) {\n                // defaultLocationSelectors should always find a location\n                locationSelectors = LayoutManager.defaultLocationSelectors;\n            }\n            const location = this.findFirstLocation(locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            }\n            else {\n                let parentItem = location.parentItem;\n                let addIdx;\n                switch (parentItem.type) {\n                    case types_1.ItemType.ground: {\n                        const groundItem = parentItem;\n                        addIdx = groundItem.addItem(itemConfig, location.index);\n                        if (addIdx >= 0) {\n                            parentItem = this._groundItem.contentItems[0]; // was added to rootItem\n                        }\n                        else {\n                            addIdx = 0; // was added as rootItem (which is the first and only ContentItem in GroundItem)\n                        }\n                        break;\n                    }\n                    case types_1.ItemType.row:\n                    case types_1.ItemType.column: {\n                        const rowOrColumn = parentItem;\n                        addIdx = rowOrColumn.addItem(itemConfig, location.index);\n                        break;\n                    }\n                    case types_1.ItemType.stack: {\n                        if (!config_1.ItemConfig.isComponent(itemConfig)) {\n                            throw Error(i18n_strings_1.i18nStrings[3 /* ItemConfigIsNotTypeComponent */]);\n                        }\n                        else {\n                            const stack = parentItem;\n                            addIdx = stack.addItem(itemConfig, location.index);\n                            break;\n                        }\n                    }\n                    case types_1.ItemType.component: {\n                        throw new internal_error_1.AssertError('LMAIALC87444602');\n                    }\n                    default:\n                        throw new internal_error_1.UnreachableCaseError('LMAIALU98881733', parentItem.type);\n                }\n                if (config_1.ItemConfig.isComponent(itemConfig)) {\n                    // see if stack was inserted\n                    const item = parentItem.contentItems[addIdx];\n                    if (content_item_1.ContentItem.isStack(item)) {\n                        parentItem = item;\n                        addIdx = 0;\n                    }\n                }\n                location.parentItem = parentItem;\n                location.index = addIdx;\n                return location;\n            }\n        }\n    }\n    /** Loads the specified component ResolvedItemConfig as root.\n     * This can be used to display a Component all by itself.  The layout cannot be changed other than having another new layout loaded.\n     * Note that, if this layout is saved and reloaded, it will reload with the Component as a child of a Stack.\n    */\n    loadComponentAsRoot(itemConfig) {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add item before init');\n        }\n        else {\n            this._groundItem.loadComponentAsRoot(itemConfig);\n        }\n    }\n    /** @deprecated Use {@link (LayoutManager:class).setSize} */\n    updateSize(width, height) {\n        this.setSize(width, height);\n    }\n    /**\n     * Updates the layout managers size\n     *\n     * @param width - Width in pixels\n     * @param height - Height in pixels\n     */\n    setSize(width, height) {\n        this._width = width;\n        this._height = height;\n        if (this._isInitialised === true) {\n            if (this._groundItem === undefined) {\n                throw new internal_error_1.UnexpectedUndefinedError('LMUS18881');\n            }\n            else {\n                this._groundItem.setSize(this._width, this._height);\n                if (this._maximisedStack) {\n                    const { width, height } = utils_1.getElementWidthAndHeight(this._containerElement);\n                    utils_1.setElementWidth(this._maximisedStack.element, width);\n                    utils_1.setElementHeight(this._maximisedStack.element, height);\n                    this._maximisedStack.updateSize();\n                }\n                this.adjustColumnsResponsive();\n            }\n        }\n    }\n    /** @internal */\n    updateSizeFromContainer() {\n        const { width, height } = utils_1.getElementWidthAndHeight(this._containerElement);\n        this.setSize(width, height);\n    }\n    /**\n     * Update the size of the root ContentItem.  This will update the size of all contentItems in the tree\n     */\n    updateRootSize() {\n        if (this._groundItem === undefined) {\n            throw new internal_error_1.UnexpectedUndefinedError('LMURS28881');\n        }\n        else {\n            this._groundItem.updateSize();\n        }\n    }\n    /** @public */\n    createAndInitContentItem(config, parent) {\n        const newItem = this.createContentItem(config, parent);\n        newItem.init();\n        return newItem;\n    }\n    /**\n     * Recursively creates new item tree structures based on a provided\n     * ItemConfiguration object\n     *\n     * @param config - ResolvedItemConfig\n     * @param parent - The item the newly created item should be a child of\n     * @internal\n     */\n    createContentItem(config, parent) {\n        if (typeof config.type !== 'string') {\n            throw new external_error_1.ConfigurationError('Missing parameter \\'type\\'', JSON.stringify(config));\n        }\n        /**\n         * We add an additional stack around every component that's not within a stack anyways.\n         */\n        if (\n        // If this is a component\n        resolved_config_1.ResolvedItemConfig.isComponentItem(config) &&\n            // and it's not already within a stack\n            !(parent instanceof stack_1.Stack) &&\n            // and we have a parent\n            !!parent &&\n            // and it's not the topmost item in a new window\n            !(this.isSubWindow === true && parent instanceof ground_item_1.GroundItem)) {\n            const stackConfig = {\n                type: types_1.ItemType.stack,\n                content: [config],\n                width: config.width,\n                minWidth: config.minWidth,\n                height: config.height,\n                minHeight: config.minHeight,\n                id: config.id,\n                maximised: config.maximised,\n                isClosable: config.isClosable,\n                activeItemIndex: 0,\n                header: undefined,\n            };\n            config = stackConfig;\n        }\n        const contentItem = this.createContentItemFromConfig(config, parent);\n        return contentItem;\n    }\n    findFirstComponentItemById(id) {\n        if (this._groundItem === undefined) {\n            throw new internal_error_1.UnexpectedUndefinedError('LMFFCIBI82446');\n        }\n        else {\n            return this.findFirstContentItemTypeByIdRecursive(types_1.ItemType.component, id, this._groundItem);\n        }\n    }\n    /**\n     * Creates a popout window with the specified content at the specified position\n     *\n     * @param itemConfigOrContentItem - The content of the popout window's layout manager derived from either\n     * a {@link (ContentItem:class)} or {@link (ItemConfig:interface)} or ResolvedItemConfig content (array of {@link (ItemConfig:interface)})\n     * @param positionAndSize - The width, height, left and top of Popout window\n     * @param parentId -The id of the element this item will be appended to when popIn is called\n     * @param indexInParent - The position of this item within its parent element\n     */\n    createPopout(itemConfigOrContentItem, positionAndSize, parentId, indexInParent) {\n        if (itemConfigOrContentItem instanceof content_item_1.ContentItem) {\n            return this.createPopoutFromContentItem(itemConfigOrContentItem, positionAndSize, parentId, indexInParent);\n        }\n        else {\n            return this.createPopoutFromItemConfig(itemConfigOrContentItem, positionAndSize, parentId, indexInParent);\n        }\n    }\n    /** @internal */\n    createPopoutFromContentItem(item, window, parentId, indexInParent) {\n        /**\n         * If the item is the only component within a stack or for some\n         * other reason the only child of its parent the parent will be destroyed\n         * when the child is removed.\n         *\n         * In order to support this we move up the tree until we find something\n         * that will remain after the item is being popped out\n         */\n        let parent = item.parent;\n        let child = item;\n        while (parent !== null && parent.contentItems.length === 1 && !parent.isGround) {\n            child = parent;\n            parent = parent.parent;\n        }\n        if (parent === null) {\n            throw new internal_error_1.UnexpectedNullError('LMCPFCI00834');\n        }\n        else {\n            if (indexInParent === undefined) {\n                indexInParent = parent.contentItems.indexOf(child);\n            }\n            if (parentId !== null) {\n                parent.addPopInParentId(parentId);\n            }\n            if (window === undefined) {\n                const windowLeft = globalThis.screenX || globalThis.screenLeft;\n                const windowTop = globalThis.screenY || globalThis.screenTop;\n                const offsetLeft = item.element.offsetLeft;\n                const offsetTop = item.element.offsetTop;\n                // const { left: offsetLeft, top: offsetTop } = getJQueryLeftAndTop(item.element);\n                const { width, height } = utils_1.getElementWidthAndHeight(item.element);\n                window = {\n                    left: windowLeft + offsetLeft,\n                    top: windowTop + offsetTop,\n                    width,\n                    height,\n                };\n            }\n            const itemConfig = item.toConfig();\n            item.remove();\n            if (!resolved_config_1.ResolvedRootItemConfig.isRootItemConfig(itemConfig)) {\n                throw new Error(`${i18n_strings_1.i18nStrings[0 /* PopoutCannotBeCreatedWithGroundItemConfig */]}`);\n            }\n            else {\n                return this.createPopoutFromItemConfig(itemConfig, window, parentId, indexInParent);\n            }\n        }\n    }\n    /** @internal */\n    createPopoutFromItemConfig(rootItemConfig, window, parentId, indexInParent) {\n        const layoutConfig = this.toConfig();\n        const popoutLayoutConfig = {\n            root: rootItemConfig,\n            openPopouts: [],\n            settings: layoutConfig.settings,\n            dimensions: layoutConfig.dimensions,\n            header: layoutConfig.header,\n            window,\n            parentId,\n            indexInParent,\n            resolved: true,\n        };\n        return this.createPopoutFromPopoutLayoutConfig(popoutLayoutConfig);\n    }\n    /** @internal */\n    createPopoutFromPopoutLayoutConfig(config) {\n        var _a, _b, _c, _d;\n        const configWindow = config.window;\n        const initialWindow = {\n            left: (_a = configWindow.left) !== null && _a !== void 0 ? _a : (globalThis.screenX || globalThis.screenLeft + 20),\n            top: (_b = configWindow.top) !== null && _b !== void 0 ? _b : (globalThis.screenY || globalThis.screenTop + 20),\n            width: (_c = configWindow.width) !== null && _c !== void 0 ? _c : 500,\n            height: (_d = configWindow.height) !== null && _d !== void 0 ? _d : 309,\n        };\n        const browserPopout = new browser_popout_1.BrowserPopout(config, initialWindow, this);\n        browserPopout.on('initialised', () => this.emit('windowOpened', browserPopout));\n        browserPopout.on('closed', () => this.reconcilePopoutWindows());\n        this._openPopouts.push(browserPopout);\n        return browserPopout;\n    }\n    /**\n     * Attaches DragListener to any given DOM element\n     * and turns it into a way of creating new ComponentItems\n     * by 'dragging' the DOM element into the layout\n     *\n     * @param element -\n     * @param componentTypeOrFtn - Type of component to be created, or a function which will provide both component type and state\n     * @param componentState - Optional initial state of component.  This will be ignored if componentTypeOrFtn is a function\n     *\n     * @returns an opaque object that identifies the DOM element\n     *          and the attached itemConfig. This can be used in\n     *          removeDragSource() later to get rid of the drag listeners.\n     */\n    newDragSource(element, componentTypeOrFtn, componentState, title) {\n        const dragSource = new drag_source_1.DragSource(this, element, [], componentTypeOrFtn, componentState, title);\n        this._dragSources.push(dragSource);\n        return dragSource;\n    }\n    /**\n     * Removes a DragListener added by createDragSource() so the corresponding\n     * DOM element is not a drag source any more.\n     */\n    removeDragSource(dragSource) {\n        utils_1.removeFromArray(dragSource, this._dragSources);\n        dragSource.destroy();\n    }\n    /** @internal */\n    startComponentDrag(x, y, dragListener, componentItem, stack) {\n        new drag_proxy_1.DragProxy(x, y, dragListener, this, componentItem, stack);\n    }\n    /**\n     * Programmatically focuses an item. This focuses the specified component item\n     * and the item emits a focus event\n     *\n     * @param item - The component item to be focused\n     * @param suppressEvent - Whether to emit focus event\n     */\n    focusComponent(item, suppressEvent = false) {\n        item.focus(suppressEvent);\n    }\n    /**\n     * Programmatically blurs (defocuses) the currently focused component.\n     * If a component item is focused, then it is blurred and and the item emits a blur event\n     *\n     * @param item - The component item to be blurred\n     * @param suppressEvent - Whether to emit blur event\n     */\n    clearComponentFocus(suppressEvent = false) {\n        this.setFocusedComponentItem(undefined, suppressEvent);\n    }\n    /**\n     * Programmatically focuses a component item or removes focus (blurs) from an existing focused component item.\n     *\n     * @param item - If defined, specifies the component item to be given focus.  If undefined, clear component focus.\n     * @param suppressEvents - Whether to emit focus and blur events\n     * @internal\n     */\n    setFocusedComponentItem(item, suppressEvents = false) {\n        if (item !== this._focusedComponentItem) {\n            let newFocusedParentItem;\n            if (item === undefined) {\n                newFocusedParentItem === undefined;\n            }\n            else {\n                newFocusedParentItem = item.parentItem;\n            }\n            if (this._focusedComponentItem !== undefined) {\n                const oldFocusedItem = this._focusedComponentItem;\n                this._focusedComponentItem = undefined;\n                oldFocusedItem.setBlurred(suppressEvents);\n                const oldFocusedParentItem = oldFocusedItem.parentItem;\n                if (newFocusedParentItem === oldFocusedParentItem) {\n                    newFocusedParentItem = undefined;\n                }\n                else {\n                    oldFocusedParentItem.setFocusedValue(false);\n                }\n            }\n            if (item !== undefined) {\n                this._focusedComponentItem = item;\n                item.setFocused(suppressEvents);\n                if (newFocusedParentItem !== undefined) {\n                    newFocusedParentItem.setFocusedValue(true);\n                }\n            }\n        }\n    }\n    /** @internal */\n    createContentItemFromConfig(config, parent) {\n        switch (config.type) {\n            case types_1.ItemType.ground: throw new internal_error_1.AssertError('LMCCIFC68871');\n            case types_1.ItemType.row: return new row_or_column_1.RowOrColumn(false, this, config, parent);\n            case types_1.ItemType.column: return new row_or_column_1.RowOrColumn(true, this, config, parent);\n            case types_1.ItemType.stack: return new stack_1.Stack(this, config, parent);\n            case types_1.ItemType.component:\n                return new component_item_1.ComponentItem(this, config, parent);\n            default:\n                throw new internal_error_1.UnreachableCaseError('CCC913564', config.type, 'Invalid Config Item type specified');\n        }\n    }\n    /**\n     * This should only be called from stack component.\n     * Stack will look after docking processing associated with maximise/minimise\n     * @internal\n     **/\n    setMaximisedStack(stack) {\n        if (stack === undefined) {\n            if (this._maximisedStack !== undefined) {\n                this.processMinimiseMaximisedStack();\n            }\n        }\n        else {\n            if (stack !== this._maximisedStack) {\n                if (this._maximisedStack !== undefined) {\n                    this.processMinimiseMaximisedStack();\n                }\n                this.processMaximiseStack(stack);\n            }\n        }\n    }\n    checkMinimiseMaximisedStack() {\n        if (this._maximisedStack !== undefined) {\n            this._maximisedStack.minimise();\n        }\n    }\n    // showAllActiveContentItems() was called from ContentItem.show().  Not sure what its purpose was so have commented out\n    // Everything seems to work ok without this.  Have left commented code just in case there was a reason for it becomes\n    // apparent\n    // /** @internal */\n    // showAllActiveContentItems(): void {\n    //     const allStacks = this.getAllStacks();\n    //     for (let i = 0; i < allStacks.length; i++) {\n    //         const stack = allStacks[i];\n    //         const activeContentItem = stack.getActiveComponentItem();\n    //         if (activeContentItem !== undefined) {\n    //             if (!(activeContentItem instanceof ComponentItem)) {\n    //                 throw new AssertError('LMSAACIS22298');\n    //             } else {\n    //                 activeContentItem.container.show();\n    //             }\n    //         }\n    //     }\n    // }\n    // hideAllActiveContentItems() was called from ContentItem.hide().  Not sure what its purpose was so have commented out\n    // Everything seems to work ok without this.  Have left commented code just in case there was a reason for it becomes\n    // apparent\n    // /** @internal */\n    // hideAllActiveContentItems(): void {\n    //     const allStacks = this.getAllStacks();\n    //     for (let i = 0; i < allStacks.length; i++) {\n    //         const stack = allStacks[i];\n    //         const activeContentItem = stack.getActiveComponentItem();\n    //         if (activeContentItem !== undefined) {\n    //             if (!(activeContentItem instanceof ComponentItem)) {\n    //                 throw new AssertError('LMSAACIH22298');\n    //             } else {\n    //                 activeContentItem.container.hide();\n    //             }\n    //         }\n    //     }\n    // }\n    /** @internal */\n    cleanupBeforeMaximisedStackDestroyed(event) {\n        if (this._maximisedStack !== null && this._maximisedStack === event.target) {\n            this._maximisedStack.off('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n            this._maximisedStack = undefined;\n        }\n    }\n    /**\n     * This method is used to get around sandboxed iframe restrictions.\n     * If 'allow-top-navigation' is not specified in the iframe's 'sandbox' attribute\n     * (as is the case with codepens) the parent window is forbidden from calling certain\n     * methods on the child, such as window.close() or setting document.location.href.\n     *\n     * This prevented GoldenLayout popouts from popping in in codepens. The fix is to call\n     * _$closeWindow on the child window's gl instance which (after a timeout to disconnect\n     * the invoking method from the close call) closes itself.\n     *\n     * @internal\n     */\n    closeWindow() {\n        globalThis.setTimeout(() => globalThis.close(), 1);\n    }\n    /** @internal */\n    getArea(x, y) {\n        let matchingArea = null;\n        let smallestSurface = Infinity;\n        for (let i = 0; i < this._itemAreas.length; i++) {\n            const area = this._itemAreas[i];\n            if (x > area.x1 &&\n                x < area.x2 &&\n                y > area.y1 &&\n                y < area.y2 &&\n                smallestSurface > area.surface) {\n                smallestSurface = area.surface;\n                matchingArea = area;\n            }\n        }\n        return matchingArea;\n    }\n    /** @internal */\n    calculateItemAreas() {\n        const allContentItems = this.getAllContentItems();\n        /**\n         * If the last item is dragged out, highlight the entire container size to\n         * allow to re-drop it. this.ground.contentiItems.length === 0 at this point\n         *\n         * Don't include ground into the possible drop areas though otherwise since it\n         * will used for every gap in the layout, e.g. splitters\n         */\n        const groundItem = this._groundItem;\n        if (groundItem === undefined) {\n            throw new internal_error_1.UnexpectedUndefinedError('LMCIAR44365');\n        }\n        else {\n            if (allContentItems.length === 1) {\n                // No root ContentItem (just Ground ContentItem)\n                const groundArea = groundItem.getElementArea();\n                if (groundArea === null) {\n                    throw new internal_error_1.UnexpectedNullError('LMCIARA44365');\n                }\n                else {\n                    this._itemAreas = [groundArea];\n                }\n                return;\n            }\n            else {\n                if (groundItem.contentItems[0].isStack) {\n                    // if root is Stack, then split stack and sides of Layout are same, so skip sides\n                    this._itemAreas = [];\n                }\n                else {\n                    // sides of layout\n                    this._itemAreas = groundItem.createSideAreas();\n                }\n                for (let i = 0; i < allContentItems.length; i++) {\n                    const stack = allContentItems[i];\n                    if (content_item_1.ContentItem.isStack(stack)) {\n                        const area = stack.getArea();\n                        if (area === null) {\n                            continue;\n                        }\n                        else {\n                            this._itemAreas.push(area);\n                            const stackContentAreaDimensions = stack.contentAreaDimensions;\n                            if (stackContentAreaDimensions === undefined) {\n                                throw new internal_error_1.UnexpectedUndefinedError('LMCIASC45599');\n                            }\n                            else {\n                                const highlightArea = stackContentAreaDimensions.header.highlightArea;\n                                const surface = (highlightArea.x2 - highlightArea.x1) * (highlightArea.y2 - highlightArea.y1);\n                                const header = {\n                                    x1: highlightArea.x1,\n                                    x2: highlightArea.x2,\n                                    y1: highlightArea.y1,\n                                    y2: highlightArea.y2,\n                                    contentItem: stack,\n                                    surface,\n                                };\n                                this._itemAreas.push(header);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Called as part of loading a new layout (including initial init()).\n     * Checks to see layout has a maximised item. If so, it maximises that item.\n     * @internal\n     */\n    checkLoadedLayoutMaximiseItem() {\n        if (this._groundItem === undefined) {\n            throw new internal_error_1.UnexpectedUndefinedError('LMCLLMI43432');\n        }\n        else {\n            const configMaximisedItems = this._groundItem.getConfigMaximisedItems();\n            if (configMaximisedItems.length > 0) {\n                let item = configMaximisedItems[0];\n                if (content_item_1.ContentItem.isComponentItem(item)) {\n                    const stack = item.parent;\n                    if (stack === null) {\n                        throw new internal_error_1.UnexpectedNullError('LMXLLMI69999');\n                    }\n                    else {\n                        item = stack;\n                    }\n                }\n                if (!content_item_1.ContentItem.isStack(item)) {\n                    throw new internal_error_1.AssertError('LMCLLMI19993');\n                }\n                else {\n                    item.maximise();\n                }\n            }\n        }\n    }\n    /** @internal */\n    processMaximiseStack(stack) {\n        this._maximisedStack = stack;\n        stack.on('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n        stack.element.classList.add(\"lm_maximised\" /* Maximised */);\n        stack.element.insertAdjacentElement('afterend', this._maximisePlaceholder);\n        if (this._groundItem === undefined) {\n            throw new internal_error_1.UnexpectedUndefinedError('LMMXI19993');\n        }\n        else {\n            this._groundItem.element.prepend(stack.element);\n            const { width, height } = utils_1.getElementWidthAndHeight(this._containerElement);\n            utils_1.setElementWidth(stack.element, width);\n            utils_1.setElementHeight(stack.element, height);\n            stack.updateSize();\n            stack.focusActiveContentItem();\n            this._maximisedStack.emit('maximised');\n            this.emit('stateChanged');\n        }\n    }\n    /** @internal */\n    processMinimiseMaximisedStack() {\n        if (this._maximisedStack === undefined) {\n            throw new internal_error_1.AssertError('LMMMS74422');\n        }\n        else {\n            const stack = this._maximisedStack;\n            if (stack.parent === null) {\n                throw new internal_error_1.UnexpectedNullError('LMMI13668');\n            }\n            else {\n                stack.element.classList.remove(\"lm_maximised\" /* Maximised */);\n                this._maximisePlaceholder.insertAdjacentElement('afterend', stack.element);\n                this._maximisePlaceholder.remove();\n                stack.parent.updateSize();\n                this._maximisedStack = undefined;\n                stack.off('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n                stack.emit('minimised');\n                this.emit('stateChanged');\n            }\n        }\n    }\n    /**\n     * Iterates through the array of open popout windows and removes the ones\n     * that are effectively closed. This is necessary due to the lack of reliably\n     * listening for window.close / unload events in a cross browser compatible fashion.\n     * @internal\n     */\n    reconcilePopoutWindows() {\n        const openPopouts = [];\n        for (let i = 0; i < this._openPopouts.length; i++) {\n            if (this._openPopouts[i].getWindow().closed === false) {\n                openPopouts.push(this._openPopouts[i]);\n            }\n            else {\n                this.emit('windowClosed', this._openPopouts[i]);\n            }\n        }\n        if (this._openPopouts.length !== openPopouts.length) {\n            this._openPopouts = openPopouts;\n            this.emit('stateChanged');\n        }\n    }\n    /**\n     * Returns a flattened array of all content items,\n     * regardles of level or type\n     * @internal\n     */\n    getAllContentItems() {\n        if (this._groundItem === undefined) {\n            throw new internal_error_1.UnexpectedUndefinedError('LMGACI13130');\n        }\n        else {\n            return this._groundItem.getAllContentItems();\n        }\n    }\n    /**\n     * Binds to DOM/BOM events on init\n     * @internal\n     */\n    bindEvents() {\n        if (this._isFullPage) {\n            globalThis.addEventListener('resize', this._windowResizeListener, { passive: true });\n        }\n        globalThis.addEventListener('unload', this._windowUnloadListener, { passive: true });\n        globalThis.addEventListener('beforeunload', this._windowUnloadListener, { passive: true });\n    }\n    /**\n     * Debounces resize events\n     * @internal\n     */\n    processResizeWithDebounce() {\n        if (this._resizeTimeoutId !== undefined) {\n            clearTimeout(this._resizeTimeoutId);\n        }\n        this._resizeTimeoutId = setTimeout(() => this.updateSizeFromContainer(), 100);\n    }\n    /**\n     * Determines what element the layout will be created in\n     * @internal\n     */\n    setContainer() {\n        var _a;\n        const bodyElement = document.body;\n        const containerElement = (_a = this._containerElement) !== null && _a !== void 0 ? _a : bodyElement;\n        if (containerElement === bodyElement) {\n            this._isFullPage = true;\n            const documentElement = document.documentElement;\n            documentElement.style.height = '100%';\n            documentElement.style.margin = '0';\n            documentElement.style.padding = '0';\n            documentElement.style.overflow = 'hidden';\n            bodyElement.style.height = '100%';\n            bodyElement.style.margin = '0';\n            bodyElement.style.padding = '0';\n            bodyElement.style.overflow = 'hidden';\n        }\n        this._containerElement = containerElement;\n    }\n    /**\n     * Called when the window is closed or the user navigates away\n     * from the page\n     * @internal\n     */\n    onUnload() {\n        this.destroy();\n    }\n    /**\n     * Adjusts the number of columns to be lower to fit the screen and still maintain minItemWidth.\n     * @internal\n     */\n    adjustColumnsResponsive() {\n        if (this._groundItem === undefined) {\n            throw new internal_error_1.UnexpectedUndefinedError('LMACR20883');\n        }\n        else {\n            this._firstLoad = false;\n            // If there is no min width set, or not content items, do nothing.\n            if (this.useResponsiveLayout() &&\n                !this._updatingColumnsResponsive &&\n                this._groundItem.contentItems.length > 0 &&\n                this._groundItem.contentItems[0].isRow) {\n                if (this._groundItem === undefined || this._width === null) {\n                    throw new internal_error_1.UnexpectedUndefinedError('LMACR77412');\n                }\n                else {\n                    // If there is only one column, do nothing.\n                    const columnCount = this._groundItem.contentItems[0].contentItems.length;\n                    if (columnCount <= 1) {\n                        return;\n                    }\n                    else {\n                        // If they all still fit, do nothing.\n                        const minItemWidth = this.layoutConfig.dimensions.minItemWidth;\n                        const totalMinWidth = columnCount * minItemWidth;\n                        if (totalMinWidth <= this._width) {\n                            return;\n                        }\n                        else {\n                            // Prevent updates while it is already happening.\n                            this._updatingColumnsResponsive = true;\n                            // Figure out how many columns to stack, and put them all in the first stack container.\n                            const finalColumnCount = Math.max(Math.floor(this._width / minItemWidth), 1);\n                            const stackColumnCount = columnCount - finalColumnCount;\n                            const rootContentItem = this._groundItem.contentItems[0];\n                            const allStacks = this.getAllStacks();\n                            if (allStacks.length === 0) {\n                                throw new internal_error_1.AssertError('LMACRS77413');\n                            }\n                            else {\n                                const firstStackContainer = allStacks[0];\n                                for (let i = 0; i < stackColumnCount; i++) {\n                                    // Stack from right.\n                                    const column = rootContentItem.contentItems[rootContentItem.contentItems.length - 1];\n                                    this.addChildContentItemsToContainer(firstStackContainer, column);\n                                }\n                                this._updatingColumnsResponsive = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Determines if responsive layout should be used.\n     *\n     * @returns True if responsive layout should be used; otherwise false.\n     * @internal\n     */\n    useResponsiveLayout() {\n        const settings = this.layoutConfig.settings;\n        const alwaysResponsiveMode = settings.responsiveMode === types_1.ResponsiveMode.always;\n        const onLoadResponsiveModeAndFirst = settings.responsiveMode === types_1.ResponsiveMode.onload && this._firstLoad;\n        return alwaysResponsiveMode || onLoadResponsiveModeAndFirst;\n    }\n    /**\n     * Adds all children of a node to another container recursively.\n     * @param container - Container to add child content items to.\n     * @param node - Node to search for content items.\n     * @internal\n     */\n    addChildContentItemsToContainer(container, node) {\n        const contentItems = node.contentItems;\n        if (node instanceof stack_1.Stack) {\n            for (let i = 0; i < contentItems.length; i++) {\n                const item = contentItems[i];\n                node.removeChild(item, true);\n                container.addChild(item);\n            }\n        }\n        else {\n            for (let i = 0; i < contentItems.length; i++) {\n                const item = contentItems[i];\n                this.addChildContentItemsToContainer(container, item);\n            }\n        }\n    }\n    /**\n     * Finds all the stacks.\n     * @returns The found stack containers.\n     * @internal\n     */\n    getAllStacks() {\n        if (this._groundItem === undefined) {\n            throw new internal_error_1.UnexpectedUndefinedError('LMFASC52778');\n        }\n        else {\n            const stacks = [];\n            this.findAllStacksRecursive(stacks, this._groundItem);\n            return stacks;\n        }\n    }\n    /** @internal */\n    findFirstContentItemType(type) {\n        if (this._groundItem === undefined) {\n            throw new internal_error_1.UnexpectedUndefinedError('LMFFCIT82446');\n        }\n        else {\n            return this.findFirstContentItemTypeRecursive(type, this._groundItem);\n        }\n    }\n    /** @internal */\n    findFirstContentItemTypeRecursive(type, node) {\n        const contentItems = node.contentItems;\n        const contentItemCount = contentItems.length;\n        if (contentItemCount === 0) {\n            return undefined;\n        }\n        else {\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem.type === type) {\n                    return contentItem;\n                }\n            }\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                const foundContentItem = this.findFirstContentItemTypeRecursive(type, contentItem);\n                if (foundContentItem !== undefined) {\n                    return foundContentItem;\n                }\n            }\n            return undefined;\n        }\n    }\n    /** @internal */\n    findFirstContentItemTypeByIdRecursive(type, id, node) {\n        const contentItems = node.contentItems;\n        const contentItemCount = contentItems.length;\n        if (contentItemCount === 0) {\n            return undefined;\n        }\n        else {\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem.type === type && contentItem.id === id) {\n                    return contentItem;\n                }\n            }\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                const foundContentItem = this.findFirstContentItemTypeByIdRecursive(type, id, contentItem);\n                if (foundContentItem !== undefined) {\n                    return foundContentItem;\n                }\n            }\n            return undefined;\n        }\n    }\n    /**\n     * Finds all the stack containers.\n     *\n     * @param stacks - Set of containers to populate.\n     * @param node - Current node to process.\n     * @internal\n     */\n    findAllStacksRecursive(stacks, node) {\n        const contentItems = node.contentItems;\n        for (let i = 0; i < contentItems.length; i++) {\n            const item = contentItems[i];\n            if (item instanceof stack_1.Stack) {\n                stacks.push(item);\n            }\n            else {\n                if (!item.isComponent) {\n                    this.findAllStacksRecursive(stacks, item);\n                }\n            }\n        }\n    }\n    /** @internal */\n    findFirstLocation(selectors) {\n        const count = selectors.length;\n        for (let i = 0; i < count; i++) {\n            const selector = selectors[i];\n            const location = this.findLocation(selector);\n            if (location !== undefined) {\n                return location;\n            }\n        }\n        return undefined;\n    }\n    /** @internal */\n    findLocation(selector) {\n        const selectorIndex = selector.index;\n        switch (selector.typeId) {\n            case 0 /* FocusedItem */: {\n                if (this._focusedComponentItem === undefined) {\n                    return undefined;\n                }\n                else {\n                    const parentItem = this._focusedComponentItem.parentItem;\n                    const parentContentItems = parentItem.contentItems;\n                    const parentContentItemCount = parentContentItems.length;\n                    if (selectorIndex === undefined) {\n                        return { parentItem, index: parentContentItemCount };\n                    }\n                    else {\n                        const focusedIndex = parentContentItems.indexOf(this._focusedComponentItem);\n                        const index = focusedIndex + selectorIndex;\n                        if (index < 0 || index > parentContentItemCount) {\n                            return undefined;\n                        }\n                        else {\n                            return { parentItem, index };\n                        }\n                    }\n                }\n            }\n            case 1 /* FocusedStack */: {\n                if (this._focusedComponentItem === undefined) {\n                    return undefined;\n                }\n                else {\n                    const parentItem = this._focusedComponentItem.parentItem;\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case 2 /* FirstStack */: {\n                const parentItem = this.findFirstContentItemType(types_1.ItemType.stack);\n                if (parentItem === undefined) {\n                    return undefined;\n                }\n                else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case 3 /* FirstRowOrColumn */: {\n                let parentItem = this.findFirstContentItemType(types_1.ItemType.row);\n                if (parentItem !== undefined) {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n                else {\n                    parentItem = this.findFirstContentItemType(types_1.ItemType.column);\n                    if (parentItem !== undefined) {\n                        return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                    }\n                    else {\n                        return undefined;\n                    }\n                }\n            }\n            case 4 /* FirstRow */: {\n                const parentItem = this.findFirstContentItemType(types_1.ItemType.row);\n                if (parentItem === undefined) {\n                    return undefined;\n                }\n                else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case 5 /* FirstColumn */: {\n                const parentItem = this.findFirstContentItemType(types_1.ItemType.column);\n                if (parentItem === undefined) {\n                    return undefined;\n                }\n                else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case 6 /* Empty */: {\n                if (this._groundItem === undefined) {\n                    throw new internal_error_1.UnexpectedUndefinedError('LMFLRIF18244');\n                }\n                else {\n                    if (this.rootItem !== undefined) {\n                        return undefined;\n                    }\n                    else {\n                        if (selectorIndex === undefined || selectorIndex === 0)\n                            return { parentItem: this._groundItem, index: 0 };\n                        else {\n                            return undefined;\n                        }\n                    }\n                }\n            }\n            case 7 /* Root */: {\n                if (this._groundItem === undefined) {\n                    throw new internal_error_1.UnexpectedUndefinedError('LMFLF18244');\n                }\n                else {\n                    const groundContentItems = this._groundItem.contentItems;\n                    if (groundContentItems.length === 0) {\n                        if (selectorIndex === undefined || selectorIndex === 0)\n                            return { parentItem: this._groundItem, index: 0 };\n                        else {\n                            return undefined;\n                        }\n                    }\n                    else {\n                        const parentItem = groundContentItems[0];\n                        return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                    }\n                }\n            }\n        }\n    }\n    /** @internal */\n    tryCreateLocationFromParentItem(parentItem, selectorIndex) {\n        const parentContentItems = parentItem.contentItems;\n        const parentContentItemCount = parentContentItems.length;\n        if (selectorIndex === undefined) {\n            return { parentItem, index: parentContentItemCount };\n        }\n        else {\n            if (selectorIndex < 0 || selectorIndex > parentContentItemCount) {\n                return undefined;\n            }\n            else {\n                return { parentItem, index: selectorIndex };\n            }\n        }\n    }\n}\nexports.LayoutManager = LayoutManager;\n/** @public */\n(function (LayoutManager) {\n    function createMaximisePlaceElement(document) {\n        const element = document.createElement('div');\n        element.classList.add(\"lm_maximise_place\" /* MaximisePlace */);\n        return element;\n    }\n    LayoutManager.createMaximisePlaceElement = createMaximisePlaceElement;\n    function createTabDropPlaceholderElement(document) {\n        const element = document.createElement('div');\n        element.classList.add(\"lm_drop_tab_placeholder\" /* DropTabPlaceholder */);\n        return element;\n    }\n    LayoutManager.createTabDropPlaceholderElement = createTabDropPlaceholderElement;\n    /**\n     * Default LocationSelectors array used if none is specified.  Will always find a location.\n     * @public\n     */\n    LayoutManager.defaultLocationSelectors = [\n        { typeId: 1 /* FocusedStack */, index: undefined },\n        { typeId: 2 /* FirstStack */, index: undefined },\n        { typeId: 3 /* FirstRowOrColumn */, index: undefined },\n        { typeId: 7 /* Root */, index: undefined },\n    ];\n    /**\n     * LocationSelectors to try to get location next to existing focused item\n     * @public\n     */\n    LayoutManager.afterFocusedItemIfPossibleLocationSelectors = [\n        { typeId: 0 /* FocusedItem */, index: 1 },\n        { typeId: 2 /* FirstStack */, index: undefined },\n        { typeId: 3 /* FirstRowOrColumn */, index: undefined },\n        { typeId: 7 /* Root */, index: undefined },\n    ];\n})(LayoutManager = exports.LayoutManager || (exports.LayoutManager = {}));\n//# sourceMappingURL=layout-manager.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","LayoutManager","config_1","resolved_config_1","browser_popout_1","drag_proxy_1","drag_source_1","drop_target_indicator_1","transition_indicator_1","external_error_1","internal_error_1","component_item_1","content_item_1","ground_item_1","row_or_column_1","stack_1","config_minifier_1","event_emitter_1","event_hub_1","i18n_strings_1","types_1","utils_1","EventEmitter","parameters","_isInitialised","_isFullPage","_groundItem","undefined","_openPopouts","_transitionIndicator","_dropTargetIndicator","_componentTypes","_itemAreas","_maximisePlaceholder","createMaximisePlaceElement","document","_tabDropPlaceholder","createTabDropPlaceholderElement","_dragSources","_updatingColumnsResponsive","_firstLoad","_eventHub","EventHub","_height","_width","_windowResizeListener","this._windowResizeListener","processResizeWithDebounce","_windowUnloadListener","this._windowUnloadListener","onUnload","_maximisedStackBeforeDestroyedListener","ev","this._maximisedStackBeforeDestroyedListener","cleanupBeforeMaximisedStackDestroyed","layoutConfig","ResolvedLayoutConfig","createDefault","isSubWindow","I18nStrings","checkInitialise","ConfigMinifier","containerElement","_containerElement","Error","contentItems","length","_focusedComponentItem","_maximisedStack","settings","closePopoutsOnUnload","i","close","globalThis","removeEventListener","destroy","remove","dragSource","releaseComponentEvent","getComponentEvent","config","minifyConfig","unminifyConfig","name","componentConstructorOrFactoryFtn","ApiError","hasOwnProperty","registerComponentConstructor","registerComponentFactoryFunction","typeName","componentConstructor","i18nStrings","constructor","factoryFunction","componentFactoryFunction","callback","registerGetComponentConstructorCallback","_getComponentConstructorFtn","console","warn","keys","instantiator","ResolvedComponentItemConfig","resolveComponentTypeName","container","itemConfig","componentState","deepExtendValue","component","AssertError","setContainer","DropTargetIndicator","TransitionIndicator","updateSizeFromContainer","GroundItem","root","init","checkLoadedLayoutMaximiseItem","bindEvents","adjustColumnsResponsive","emit","isInitialised","UnexpectedUndefinedError","LayoutConfig","resolve","loadRoot","groundContent","calculateConfigContent","rootItemConfig","reconcilePopoutWindows","openPopouts","push","toConfig","Settings","createCopy","dimensions","Dimensions","header","Header","resolved","saveLayout","componentType","title","componentItem","newComponentAtLocation","locationSelectors","location","addComponentAtLocation","createdItem","parentItem","index","ContentItem","isComponentItem","addItemAtLocation","type","contentItem","newItemAtLocation","defaultLocationSelectors","findFirstLocation","addIdx","ItemType","ground","addItem","row","column","stack","ItemConfig","isComponent","UnreachableCaseError","item","isStack","loadComponentAsRoot","width","height","setSize","getElementWidthAndHeight","setElementWidth","element","setElementHeight","updateSize","parent","newItem","createContentItem","ConfigurationError","JSON","stringify","ResolvedItemConfig","Stack","stackConfig","content","minWidth","minHeight","id","maximised","isClosable","activeItemIndex","createContentItemFromConfig","findFirstContentItemTypeByIdRecursive","itemConfigOrContentItem","positionAndSize","parentId","indexInParent","createPopoutFromContentItem","createPopoutFromItemConfig","window","child","isGround","UnexpectedNullError","indexOf","addPopInParentId","windowLeft","screenX","screenLeft","windowTop","screenY","screenTop","offsetLeft","offsetTop","left","top","ResolvedRootItemConfig","isRootItemConfig","createPopoutFromPopoutLayoutConfig","popoutLayoutConfig","_a","_b","_c","_d","configWindow","initialWindow","browserPopout","BrowserPopout","on","componentTypeOrFtn","DragSource","removeFromArray","x","y","dragListener","DragProxy","suppressEvent","focus","setFocusedComponentItem","suppressEvents","newFocusedParentItem","oldFocusedItem","setBlurred","oldFocusedParentItem","setFocusedValue","setFocused","RowOrColumn","ComponentItem","processMinimiseMaximisedStack","processMaximiseStack","minimise","event","target","off","setTimeout","matchingArea","smallestSurface","Infinity","area","x1","x2","y1","y2","surface","allContentItems","getAllContentItems","groundItem","groundArea","getElementArea","createSideAreas","getArea","stackContentAreaDimensions","contentAreaDimensions","highlightArea","configMaximisedItems","getConfigMaximisedItems","maximise","classList","add","insertAdjacentElement","prepend","focusActiveContentItem","getWindow","closed","addEventListener","passive","_resizeTimeoutId","clearTimeout","bodyElement","body","documentElement","style","margin","padding","overflow","useResponsiveLayout","isRow","columnCount","minItemWidth","stackColumnCount","Math","max","finalColumnCount","floor","rootContentItem","allStacks","getAllStacks","firstStackContainer","addChildContentItemsToContainer","onLoadResponsiveModeAndFirst","responsiveMode","ResponsiveMode","onload","always","node","removeChild","addChild","stacks","findAllStacksRecursive","findFirstContentItemTypeRecursive","contentItemCount","foundContentItem","selectors","count","findLocation","selector","selectorIndex","typeId","parentContentItems","parentContentItemCount","focusedIndex","tryCreateLocationFromParentItem","findFirstContentItemType","rootItem","groundContentItems","createElement","afterFocusedItemIfPossibleLocationSelectors"]
}
